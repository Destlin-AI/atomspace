#
# OpenCogGenTypes.cmake
#
# Definitions for automatically building the atom_types files, given
# a master file "atom_types.script" that defines all of the type
# relationships.
#
# Macro example call:
# XXX TBD

# ----------------------------------------------------------------------
# Write out the initial boilerplate for the four C++ files.
# Not for external use.
MACRO(OPENCOG_CPP_SETUP TMPHDR_FILE DEFINITIONS_FILE INHERITANCE_FILE CNAMES_FILE)

	SET(CLASSSERVER_REFERENCE "opencog::nameserver().")
	SET(CLASSSERVER_INSTANCE "opencog::nameserver()")

	FILE(WRITE "${TMPHDR_FILE}"
		"/* File automatically generated by the macro OPENCOG_ADD_ATOM_TYPES. Do not edit */\n"
		"#include <opencog/atoms/atom_types/types.h>\nnamespace opencog\n{\n"
	)
	FILE(WRITE "${DEFINITIONS_FILE}"
		"/* File automatically generated by the macro OPENCOG_ADD_ATOM_TYPES.  Do not edit */\n"
		"#include <opencog/atoms/atom_types/NameServer.h>\n"
		"#include <opencog/atoms/atom_types/atom_types.h>\n"
		"#include <opencog/atoms/atom_types/types.h>\n"
		"#include \"${HEADER_FILE}\"\n"
	)

	# We need to touch the class-server before doing anything.
	# This is in order to guarantee that the main atomspace types
	# get created before other derived types.
	#
	# There's still a potentially nasty bug here: if some third types.script
	# file depends on types defined in a second file, but the third initializer
	# runs before the second, then any atoms in that third file that inherit
	# from the second will get a type of zero.  This will crash code later on.
	# The only fix for this is to make sure that the third script forces the
	# initailzers for the second one to run first. Hopefully, the programmer
	# will figure this out, before the bug shows up. :-)
	FILE(WRITE "${INHERITANCE_FILE}"
		"/* File automatically generated by the macro OPENCOG_ADD_ATOM_TYPES. Do not edit */\n\n"
		"/* Touch the server before adding types. */\n"
		"${CLASSSERVER_INSTANCE};\n"
	)

	FILE(WRITE "${CNAMES_FILE}"
		"/* File automatically generated by the macro OPENCOG_ADD_ATOM_TYPES. Do not edit */\n"
		"#include <opencog/atoms/atom_types/atom_types.h>\n"
		"#include <opencog/atoms/base/Handle.h>\n"
		"#include <opencog/atoms/base/Node.h>\n"
		"#include <opencog/atoms/base/Link.h>\n\n"
		"namespace opencog {\n\n"
		"#define NODE_CTOR(FUN,TYP) inline Handle FUN(std::string name) {\\\n"
		"    return createNode(TYP, std::move(name)); }\n\n"
		"#define LINK_CTOR(FUN,TYP) template<typename ...Atoms>\\\n"
		"    inline Handle FUN(Atoms const&... atoms) {\\\n"
		"       return createLink(TYP, atoms...); }\n\n"
	)

ENDMACRO(OPENCOG_CPP_SETUP TMPHDR_FILE DEFINITIONS_FILE INHERITANCE_FILE CNAMES_FILE)

# ------------
# Print out the C++ definitions
MACRO(OPENCOG_CPP_WRITE_DEFS)

	IF (NOT "${TYPE}" STREQUAL "NOTYPE")
		FILE(APPEND "${TMPHDR_FILE}" "extern opencog::Type ${TYPE};\n")
		FILE(APPEND "${DEFINITIONS_FILE}"  "opencog::Type opencog::${TYPE};\n")
	ELSE (NOT "${TYPE}" STREQUAL "NOTYPE")
		FILE(APPEND "${TMPHDR_FILE}"
			"#ifndef _OPENCOG_NOTYPE_\n"
			"#define _OPENCOG_NOTYPE_\n"
			"// Set notype's code with the last possible Type code\n"
			"static const opencog::Type ${TYPE}=((Type) -1);\n"
			"#endif // _OPENCOG_NOTYPE_\n"
		)
	ENDIF (NOT "${TYPE}" STREQUAL "NOTYPE")

	IF (ISNODE STREQUAL "NODE" AND
		NOT SHORT_NAME STREQUAL "" AND
		NOT SHORT_NAME STREQUAL "Type")
		FILE(APPEND "${CNAMES_FILE}" "NODE_CTOR(${SHORT_NAME}, ${TYPE})\n")
	ENDIF ()
	IF (ISLINK STREQUAL "LINK" AND
		NOT SHORT_NAME STREQUAL "" AND
		NOT SHORT_NAME STREQUAL "Atom" AND
		NOT SHORT_NAME STREQUAL "Notype" AND
		NOT SHORT_NAME STREQUAL "Type" AND
		NOT SHORT_NAME STREQUAL "TypeSet" AND
		NOT SHORT_NAME STREQUAL "Arity")
		FILE(APPEND "${CNAMES_FILE}" "LINK_CTOR(${SHORT_NAME}, ${TYPE})\n")
	ENDIF ()
	# Special case...
	IF (ISNODE STREQUAL "NODE" AND
		SHORT_NAME STREQUAL "Type")
		FILE(APPEND "${CNAMES_FILE}" "NODE_CTOR(TypeNode, ${TYPE})\n")
	ENDIF ()
	IF (ISLINK STREQUAL "LINK" AND
		SHORT_NAME STREQUAL "Type")
		FILE(APPEND "${CNAMES_FILE}" "LINK_CTOR(TypeLink, ${TYPE})\n")
	ENDIF ()
	IF (ISLINK STREQUAL "LINK" AND
		SHORT_NAME STREQUAL "TypeSet")
		FILE(APPEND "${CNAMES_FILE}" "LINK_CTOR(TypeIntersection, ${TYPE})\n")
	ENDIF ()
	IF (ISLINK STREQUAL "LINK" AND
		SHORT_NAME STREQUAL "Arity")
		FILE(APPEND "${CNAMES_FILE}" "LINK_CTOR(ArityLink, ${TYPE})\n")
	ENDIF ()

	# ------------------------------------
	# Create the type inheritance C++ file.

	IF (PARENT_TYPES)
		STRING(REGEX REPLACE "[ 	]*,[ 	]*" ";" PARENT_TYPES "${PARENT_TYPES}")
		FOREACH (PARENT_TYPE ${PARENT_TYPES})
			# Skip inheritance of the special "notype" class; we could move
			# this test up but it was left here for simplicity's sake
			IF (NOT "${TYPE}" STREQUAL "NOTYPE")
				FILE(APPEND "${INHERITANCE_FILE}"
					"opencog::${TYPE} = ${CLASSSERVER_REFERENCE}"
					"declType(opencog::${PARENT_TYPE}, \"${TYPE_NAME}\");\n"
				)
			ENDIF (NOT "${TYPE}" STREQUAL "NOTYPE")
		ENDFOREACH (PARENT_TYPE)
	ELSE (PARENT_TYPES)
		IF (NOT "${TYPE}" STREQUAL "NOTYPE")
			FILE(APPEND "${INHERITANCE_FILE}"
				"opencog::${TYPE} = ${CLASSSERVER_REFERENCE}"
				"declType(opencog::${TYPE}, \"${TYPE_NAME}\");\n"
			)
		ENDIF (NOT "${TYPE}" STREQUAL "NOTYPE")
	ENDIF (PARENT_TYPES)
ENDMACRO(OPENCOG_CPP_WRITE_DEFS)

MACRO(OPENCOG_CPP_TEARDOWN)
	FILE(APPEND "${TMPHDR_FILE}" "} // namespace opencog\n")

	FILE(APPEND "${CNAMES_FILE}"
		"#undef NODE_CTOR\n"
		"#undef LINK_CTOR\n"
		"} // namespace opencog\n"
	)
ENDMACRO(OPENCOG_CPP_TEARDOWN)

# Must be last, so that all writing has completed *before* the
# file appears in the filesystem. Without this, parallel-make
# will sometimes use an incompletely-written file.
FILE(RENAME "${TMPHDR_FILE}" "${HEADER_FILE}")
# The main  macro for generating C++ type defintions
#MACRO(OPENCOG_CPP_TYPES HEADER_FILE DEFINITIONS_FILE INHERITANCE_FILE)
#	SET(TMPHDR_FILE ${CMAKE_BINARY_DIR}/tmp_types.h)
#	SET(CNAMES_FILE ${CMAKE_BINARY_DIR}/atom_names.h)
#
#	OPENCOG_CPP_SETUP(TMPHDR_FILE DEFINITIONS_FILE INHERITANCE_FILE CNAMES_FILE)
#ENDMACRO(OPENCOG_CPP_TYPES HEADER_FILE DEFINITIONS_FILE INHERITANCE_FILE)

# ===================================================================
# Atom types in guile.

MACRO(OPENCOG_SCM_SETUP SCM_FILE)
	FILE(WRITE "${SCM_FILE}"
		"\n"
		"; DO NOT EDIT THIS FILE! This file was automatically\n"
		"; generated from atom definitions in types.script\n"
		"; by the macro OPENCOG_ADD_ATOM_TYPES\n"
		";\n"
		"; This file contains basic scheme wrappers for atom creation.\n"
		";\n"
	)
ENDMACRO(OPENCOG_SCM_SETUP SCM_FILE)

# Print out the scheme definitions
MACRO(OPENCOG_SCM_WRITE_DEFS)
	FILE(APPEND "${SCM_FILE}"
		"(define-public ${TYPE_NAME}Type (cog-type->int '${TYPE_NAME}))\n"
	)

	IF (ISVALUE STREQUAL "VALUE" OR ISSTREAM STREQUAL "STREAM")
		FILE(APPEND "${SCM_FILE}"
			"(define-public (${TYPE_NAME} . x)\n"
			"\t(apply cog-new-value (cons ${TYPE_NAME}Type x)))\n"
		)
	ENDIF (ISVALUE STREQUAL "VALUE" OR ISSTREAM STREQUAL "STREAM")

	IF (ISNODE STREQUAL "NODE")
		FILE(APPEND "${SCM_FILE}"
			"(define-public (${TYPE_NAME} . x)\n"
			"\t(apply cog-new-node (cons ${TYPE_NAME}Type x)))\n"
		)
		IF (NOT SHORT_NAME STREQUAL "")
			FILE(APPEND "${SCM_FILE}"
				"(define-public (${SHORT_NAME} . x)\n"
				"\t(apply cog-new-node (cons ${TYPE_NAME}Type x)))\n"
			)
		ENDIF (NOT SHORT_NAME STREQUAL "")
	ENDIF (ISNODE STREQUAL "NODE")

	IF (ISLINK STREQUAL "LINK")
		FILE(APPEND "${SCM_FILE}"
			"(define-public (${TYPE_NAME} . x)\n"
			"\t(apply cog-new-link (cons ${TYPE_NAME}Type x)))\n"
		)
		IF (NOT SHORT_NAME STREQUAL "")
			FILE(APPEND "${SCM_FILE}"
				"(define-public (${SHORT_NAME} . x)\n"
				"\t(apply cog-new-link (cons ${TYPE_NAME}Type x)))\n"
			)
		ENDIF (NOT SHORT_NAME STREQUAL "")
	ENDIF (ISLINK STREQUAL "LINK")

	IF (ISATOMSPACE STREQUAL "ATOMSPACE")
		FILE(APPEND "${SCM_FILE}"
			"(define-public AtomSpace cog-new-atomspace)\n"
		)
	ENDIF (ISATOMSPACE STREQUAL "ATOMSPACE")

	IF (ISAST STREQUAL "AST")
		FILE(APPEND "${SCM_FILE}"
			"(define-public (${TYPE_NAME} . x)\n"
			"\t(apply cog-new-ast (cons ${TYPE_NAME}Type x)))\n"
		)
	ENDIF (ISAST STREQUAL "AST")
ENDMACRO(OPENCOG_SCM_WRITE_DEFS)

# ===================================================================
# Atom types in python.

MACRO(OPENCOG_PYTHON_SETUP PYTHON_FILE)
	FILE(WRITE "${PYTHON_FILE}"
		"\n"
		"# DO NOT EDIT THIS FILE! This file was automatically generated from atom\n"
		"# definitions in types.script by the macro OPENCOG_ADD_ATOM_TYPES\n"
		"#\n"
		"# This file contains basic python wrappers for atom creation.\n"
		"#\n"
		"\n"
	)
ENDMACRO(OPENCOG_PYTHON_SETUP PYTHON_FILE)

# ------------
# Print out the python definitions. Note: We special-case Atom
# since we don't want to create a function with the same
# identifier as the Python Atom object.
MACRO(OPENCOG_PYTHON_WRITE_DEFS)
	IF (NOT TYPE_NAME STREQUAL "Atom")
		IF (ISVALUE STREQUAL "VALUE" OR ISSTREAM STREQUAL "STREAM")
			LIST(FIND PYTHON_SUPPORTED_VALUE_LIST ${TYPE_NAME} _INDEX)
			IF (${_INDEX} GREATER -1)
				# Single arg will work as all of value constructors has
				# single argument: either value or vector.
				FILE(APPEND "${PYTHON_FILE}"
					"def ${TYPE_NAME}(arg):\n"
					"    return createValue(types.${TYPE_NAME}, arg)\n"
				)
			ENDIF (${_INDEX} GREATER -1)
		ENDIF (ISVALUE STREQUAL "VALUE" OR ISSTREAM STREQUAL "STREAM")
		IF (ISNODE STREQUAL "NODE")
			FILE(APPEND "${PYTHON_FILE}"
				"def ${TYPE_NAME}(node_name, tv=None):\n"
				"    return add_node(types.${TYPE_NAME}, node_name, tv)\n"
			)
		ENDIF (ISNODE STREQUAL "NODE")
		IF (ISLINK STREQUAL "LINK")
			FILE(APPEND "${PYTHON_FILE}"
				"def ${TYPE_NAME}(*args, tv=None):\n"
				"    return add_link(types.${TYPE_NAME}, args, tv=tv)\n"
			)
		ENDIF (ISLINK STREQUAL "LINK")
	ENDIF (NOT TYPE_NAME STREQUAL "Atom")

	# If not named as a node or a link, assume its a link
	# This is kind of hacky, but I don't know what else to do ...
	IF (NOT ISATOMSPACE STREQUAL "ATOMSPACE" AND
		NOT ISNODE STREQUAL "NODE" AND
		NOT ISLINK STREQUAL "LINK" AND
		NOT ISVALUE STREQUAL "VALUE" AND
		NOT ISSTREAM STREQUAL "STREAM")
		FILE(APPEND "${PYTHON_FILE}"
			"def ${TYPE_NAME}(*args):\n"
			"    return add_link(types.${TYPE_NAME}, args)\n"
		)
	ENDIF (NOT ISATOMSPACE STREQUAL "ATOMSPACE" AND
		NOT ISNODE STREQUAL "NODE" AND
		NOT ISLINK STREQUAL "LINK" AND
		NOT ISVALUE STREQUAL "VALUE" AND
		NOT ISSTREAM STREQUAL "STREAM")
ENDMACRO(OPENCOG_PYTHON_WRITE_DEFS)

#####################################################################
# Macro example call:
# OPENCOG_ADD_ATOM_TYPES(
#        SCRIPT_FILE
#        HEADER_FILE
#        DEFINITIONS_FILE
#        INHERITANCE_FILE
#        SCM_FILE
#        PYTHON_FILE)
#
IF (NOT SCRIPT_FILE)
    MESSAGE(FATAL_ERROR "OPENCOG_ADD_ATOM_TYPES missing SCRIPT_FILE")
ENDIF (NOT SCRIPT_FILE)

IF (NOT HEADER_FILE)
    MESSAGE(FATAL_ERROR "OPENCOG_ADD_ATOM_TYPES missing HEADER_FILE")
ENDIF (NOT HEADER_FILE)

IF (NOT DEFINITIONS_FILE)
    MESSAGE(FATAL_ERROR "OPENCOG_ADD_ATOM_TYPES missing DEFINITIONS_FILE")
ENDIF (NOT DEFINITIONS_FILE)

IF (NOT INHERITANCE_FILE)
    MESSAGE(FATAL_ERROR "OPENCOG_ADD_ATOM_TYPES missing INHERITANCE_FILE")
ENDIF (NOT INHERITANCE_FILE)

IF (NOT SCM_FILE)
    MESSAGE(FATAL_ERROR "OPENCOG_ADD_ATOM_TYPES missing SCM_FILE")
ENDIF (NOT SCM_FILE)

IF (NOT PYTHON_FILE)
    MESSAGE(FATAL_ERROR "OPENCOG_ADD_ATOM_TYPES missing PYTHON_FILE")
ENDIF (NOT PYTHON_FILE)

SET(PYTHON_SUPPORTED_VALUE_LIST)

# --------
	SET(TMPHDR_FILE ${CMAKE_BINARY_DIR}/tmp_types.h)
	SET(CNAMES_FILE ${CMAKE_BINARY_DIR}/atom_names.h)

	OPENCOG_CPP_SETUP(${TMPHDR_FILE} ${DEFINITIONS_FILE} ${INHERITANCE_FILE} ${CNAMES_FILE})

	OPENCOG_SCM_SETUP(${SCM_FILE})
	OPENCOG_PYTHON_SETUP(${PYTHON_FILE})
# -------

FILE(STRINGS "${SCRIPT_FILE}" TYPE_SCRIPT_CONTENTS)
FOREACH (LINE ${TYPE_SCRIPT_CONTENTS})
    # this regular expression is more complex than required due to cmake's
    # regex engine bugs
    STRING(REGEX MATCH "^[ 	]*([A-Z0-9_]+)?([ 	]*<-[ 	]*([A-Z0-9_, 	]+))?[ 	]*(\"[A-Za-z]*\")?[ 	]*(//.*)?[ 	]*$" MATCHED "${LINE}")
    IF (MATCHED AND CMAKE_MATCH_1)
        SET(TYPE ${CMAKE_MATCH_1})
        SET(PARENT_TYPES ${CMAKE_MATCH_3})
        SET(TYPE_NAME "")
        IF (CMAKE_MATCH_4)
            MESSAGE(STATUS "Custom atom type name specified: ${CMAKE_MATCH_4}")
            STRING(REGEX MATCHALL "." CHARS ${CMAKE_MATCH_4})
            LIST(LENGTH CHARS LIST_LENGTH)
            MATH(EXPR LAST_INDEX "${LIST_LENGTH} - 1")
            FOREACH(I RANGE ${LAST_INDEX})
                LIST(GET CHARS ${I} C)
                IF (NOT ${C} STREQUAL "\"")
                    SET(TYPE_NAME "${TYPE_NAME}${C}")
                ENDIF (NOT ${C} STREQUAL "\"")
            ENDFOREACH(I RANGE ${LIST_LENGTH})
        ENDIF (CMAKE_MATCH_4)

        IF (TYPE_NAME STREQUAL "")
            # Set type name using camel casing
            STRING(REGEX MATCHALL "." CHARS ${TYPE})
            LIST(LENGTH CHARS LIST_LENGTH)
            MATH(EXPR LAST_INDEX "${LIST_LENGTH} - 1")
            FOREACH(I RANGE ${LAST_INDEX})
                LIST(GET CHARS ${I} C)
                IF (NOT ${C} STREQUAL "_")
                    MATH(EXPR IP "${I} - 1")
                    LIST(GET CHARS ${IP} CP)
                    IF (${I} EQUAL 0)
                        SET(TYPE_NAME "${TYPE_NAME}${C}")
                    ELSE (${I} EQUAL 0)
                        IF (${CP} STREQUAL "_")
                            SET(TYPE_NAME "${TYPE_NAME}${C}")
                        ELSE (${CP} STREQUAL "_")
                            STRING(TOLOWER "${C}" CL)
                            SET(TYPE_NAME "${TYPE_NAME}${CL}")
                        ENDIF (${CP} STREQUAL "_")
                    ENDIF (${I} EQUAL 0)
                ENDIF (NOT ${C} STREQUAL "_")
            ENDFOREACH(I RANGE ${LIST_LENGTH})
        ENDIF (TYPE_NAME STREQUAL "")

        STRING(REGEX REPLACE "([a-zA-Z]*)(Link|Node)$" "\\1" SHORT_NAME ${TYPE_NAME})
        MESSAGE(STATUS "Atom type name: ${TYPE_NAME} ${SHORT_NAME}")

        # -----------------------------------------------------------
        # Try to guess if the thing is a node or link based on its name
        STRING(REGEX MATCH "VALUE$" ISVALUE ${TYPE})
        STRING(REGEX MATCH "STREAM$" ISSTREAM ${TYPE})
        STRING(REGEX MATCH "ATOMSPACE$" ISATOMSPACE ${TYPE})
        STRING(REGEX MATCH "NODE$" ISNODE ${TYPE})
        STRING(REGEX MATCH "LINK$" ISLINK ${TYPE})
        STRING(REGEX MATCH "AST$" ISAST ${TYPE})

        # If not explicitly named, assume its a link. This is kind of
        # hacky, but is needed for e.g. "VariableList" ...
        IF (NOT ISNODE STREQUAL "NODE"
            AND NOT ISVALUE STREQUAL "VALUE"
            AND NOT ISSTREAM STREQUAL "STREAM"
            AND NOT ISATOMSPACE STREQUAL "ATOMSPACE"
            AND NOT ISAST STREQUAL "AST")
            SET(ISLINK "LINK")
        ENDIF (NOT ISNODE STREQUAL "NODE"
            AND NOT ISVALUE STREQUAL "VALUE"
            AND NOT ISSTREAM STREQUAL "STREAM"
            AND NOT ISATOMSPACE STREQUAL "ATOMSPACE"
            AND NOT ISAST STREQUAL "AST")

        IF (${TYPE} STREQUAL "VALUATION")
            SET(ISLINK "")
        ENDIF (${TYPE} STREQUAL "VALUATION")

        # -----------------------------------------------------------
        # Print out the C++ definitions
        OPENCOG_CPP_WRITE_DEFS()

        # -----------------------------------------------------------
        # Print out the scheme definitions
        OPENCOG_SCM_WRITE_DEFS()

        # -----------------------------------------------------------
        # Print out the python definitions.
        OPENCOG_PYTHON_WRITE_DEFS()

    ELSE (MATCHED AND CMAKE_MATCH_1)
        IF (NOT MATCHED)
            MESSAGE(FATAL_ERROR "Invalid line in ${SCRIPT_FILE} file: [${LINE}]")
        ENDIF (NOT MATCHED)
    ENDIF (MATCHED AND CMAKE_MATCH_1)
ENDFOREACH (LINE)

OPENCOG_CPP_TEARDOWN()
